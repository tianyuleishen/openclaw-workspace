/**
 * OpenClaw Vulnerability Scanner
 * Regularly scans the system for potential vulnerabilities
 */

const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');
const util = require('util');
const execAsync = util.promisify(exec);

class VulnerabilityScanner {
  constructor() {
    this.scanHistory = [];
    this.vulnerabilityDatabase = [];
    this.lastScan = null;
    this.scanInterval = null;
  }

  /**
   * Start regular vulnerability scanning
   */
  startRegularScanning(intervalMinutes = 60) {
    console.log(`ğŸ”„ Starting regular vulnerability scanning (every ${intervalMinutes} minutes)...`);
    
    // Perform initial scan
    this.performScan();
    
    // Set up recurring scans
    this.scanInterval = setInterval(() => {
      this.performScan();
    }, intervalMinutes * 60 * 1000);
    
    console.log(`âœ… Vulnerability scanner started. Next scan in ${intervalMinutes} minutes.`);
  }

  /**
   * Perform a comprehensive vulnerability scan
   */
  async performScan() {
    console.log(`ğŸ” Starting vulnerability scan at ${new Date().toISOString()}...`);
    
    const scanStartTime = Date.now();
    const scanReport = {
      timestamp: new Date().toISOString(),
      duration: 0,
      findings: [],
      severityStats: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0
      },
      systemInfo: await this.getSystemInfo()
    };

    try {
      // 1. Check for security misconfigurations
      const configIssues = await this.checkSecurityConfigurations();
      scanReport.findings.push(...configIssues);

      // 2. Scan file permissions
      const permissionIssues = await this.checkFilePermissions();
      scanReport.findings.push(...permissionIssues);

      // 3. Check for exposed secrets
      const secretLeaks = await this.checkExposedSecrets();
      scanReport.findings.push(...secretLeaks);

      // 4. Analyze dependencies for known vulnerabilities
      const dependencyIssues = await this.checkDependencies();
      scanReport.findings.push(...dependencyIssues);

      // 5. Check for outdated components
      const outdatedComponents = await this.checkOutdatedComponents();
      scanReport.findings.push(...outdatedComponents);

      // Calculate severity stats
      scanReport.findings.forEach(finding => {
        scanReport.severityStats[finding.severity]++;
      });

      scanReport.duration = Date.now() - scanStartTime;

      // Save scan report
      await this.saveScanReport(scanReport);

      // Generate summary
      this.generateScanSummary(scanReport);

      // Check if critical vulnerabilities were found
      if (scanReport.severityStats.critical > 0) {
        console.log(`ğŸš¨ CRITICAL VULNERABILITIES DETECTED! Immediate attention required.`);
        this.sendAlert('CRITICAL_VULNERABILITY_DETECTED', scanReport);
      }

      console.log(`âœ… Vulnerability scan completed in ${scanReport.duration}ms`);
    } catch (error) {
      console.error(`âŒ Vulnerability scan failed:`, error);
      this.sendAlert('SCAN_FAILED', { error: error.message });
    }

    this.lastScan = scanReport;
    this.scanHistory.push(scanReport);
    
    // Keep only the last 10 scans in memory
    if (this.scanHistory.length > 10) {
      this.scanHistory = this.scanHistory.slice(-10);
    }
  }

  /**
   * Check security configurations
   */
  async checkSecurityConfigurations() {
    const findings = [];
    
    // Check if security features are enabled
    try {
      const healthCheck = await this.httpGet('http://localhost:3009/health');
      if (healthCheck.status !== 200 || healthCheck.data.status !== 'healthy') {
        findings.push({
          id: 'SECURITY_SERVICE_DOWN',
          title: 'Security service is not running properly',
          description: 'The OpenClaw Security Defense System is not responding correctly',
          severity: 'critical',
          location: 'Service Health Check',
          recommendation: 'Restart the security service and check logs'
        });
      }
    } catch (error) {
      findings.push({
        id: 'SECURITY_SERVICE_UNAVAILABLE',
        title: 'Security service is unavailable',
        description: 'Cannot connect to the OpenClaw Security Defense System',
        severity: 'critical',
        location: 'Service Availability',
        recommendation: 'Verify the security service is running on port 3009'
      });
    }
    
    // Check if environment variables are properly secured
    const sensitiveEnvVars = ['API_KEY', 'SECRET_KEY', 'PASSWORD', 'TOKEN'];
    for (const envVar of sensitiveEnvVars) {
      if (process.env[envVar] && process.env[envVar].length > 0) {
        // Check if the environment variable is accessible inappropriately
        findings.push({
          id: 'ENV_VAR_VISIBLE',
          title: `Environment variable ${envVar} is exposed`,
          description: `The environment variable ${envVar} is visible to the application`,
          severity: 'medium',
          location: 'Environment Variables',
          recommendation: 'Ensure sensitive environment variables are properly managed and not logged'
        });
      }
    }
    
    return findings;
  }

  /**
   * Check file permissions
   */
  async checkFilePermissions() {
    const findings = [];
    const workspacePath = path.join(__dirname);
    
    try {
      // Check workspace directory permissions
      const workspaceStat = fs.statSync(workspacePath);
      if (workspaceStat.mode & fs.constants.S_IWOTH) { // World writable
        findings.push({
          id: 'WORKSPACE_WORLD_WRITABLE',
          title: 'Workspace directory is world-writable',
          description: 'The workspace directory allows write access to any user',
          severity: 'high',
          location: workspacePath,
          recommendation: 'Change directory permissions to restrict write access'
        });
      }
      
      // Check for sensitive files with loose permissions
      const sensitiveFiles = [
        path.join(workspacePath, '.env'),
        path.join(workspacePath, 'config.json'),
        path.join(workspacePath, 'credentials.json')
      ];
      
      for (const filePath of sensitiveFiles) {
        if (fs.existsSync(filePath)) {
          const stat = fs.statSync(filePath);
          if (stat.mode & fs.constants.S_IROTH) { // World readable
            findings.push({
              id: 'SENSITIVE_FILE_PUBLIC',
              title: `Sensitive file ${path.basename(filePath)} is world-readable`,
              description: `The file ${filePath} allows read access to any user`,
              severity: 'high',
              location: filePath,
              recommendation: 'Restrict file permissions to owner only (chmod 600)'
            });
          }
        }
      }
    } catch (error) {
      findings.push({
        id: 'PERMISSION_CHECK_ERROR',
        title: 'Error checking file permissions',
        description: `Failed to check file permissions: ${error.message}`,
        severity: 'medium',
        location: 'File System',
        recommendation: 'Verify file system access permissions'
      });
    }
    
    return findings;
  }

  /**
   * Check for exposed secrets
   */
  async checkExposedSecrets() {
    const findings = [];
    const workspacePath = path.join(__dirname);
    
    try {
      // Look for common secret patterns in files
      const filesToCheck = this.getAllFiles(workspacePath).filter(file => 
        file.endsWith('.js') || 
        file.endsWith('.json') || 
        file.endsWith('.md') || 
        file.endsWith('.txt') ||
        file.endsWith('.env')
      );
      
      for (const filePath of filesToCheck) {
        try {
          const content = fs.readFileSync(filePath, 'utf8');
          
          // Check for common secret patterns
          const secretPatterns = [
            { pattern: /api[_-]?key["']?\s*[:=]\s*["']?([A-Za-z0-9_\-]{20,})["']?/gi, type: 'API Key' },
            { pattern: /password["']?\s*[:=]\s*["']?([^"'\s]{8,})["']?/gi, type: 'Password' },
            { pattern: /secret["']?\s*[:=]\s*["']?([A-Za-z0-9_\-]{20,})["']?/gi, type: 'Secret' },
            { pattern: /token["']?\s*[:=]\s*["']?([A-Za-z0-9_\-]{20,})["']?/gi, type: 'Token' },
            { pattern: /sk-[A-Za-z0-9]{20,}/gi, type: 'Stripe Key' },
            { pattern: /gh[pousr]_[A-Za-z0-9_]{35,}/gi, type: 'GitHub Token' },
            { pattern: /AIza[a-zA-Z0-9_\-]{35,}/gi, type: 'Google API Key' }
          ];
          
          for (const { pattern, type } of secretPatterns) {
            let match;
            while ((match = pattern.exec(content)) !== null) {
              findings.push({
                id: 'EXPOSED_SECRET_FOUND',
                title: `Exposed ${type} found in ${path.basename(filePath)}`,
                description: `Potentially exposed ${type} found in ${filePath}`,
                severity: 'critical',
                location: `${filePath}:${this.getLineNumberOfOffset(content, match.index)}`,
                recommendation: 'Remove exposed secrets and regenerate them',
                evidence: match[0].substring(0, 50) + '...'
              });
            }
          }
        } catch (error) {
          // File might be binary or inaccessible, skip it
          continue;
        }
      }
    } catch (error) {
      findings.push({
        id: 'SECRET_SCAN_ERROR',
        title: 'Error scanning for exposed secrets',
        description: `Failed to scan for exposed secrets: ${error.message}`,
        severity: 'medium',
        location: 'File System',
        recommendation: 'Verify file system access permissions'
      });
    }
    
    return findings;
  }

  /**
   * Check dependencies for known vulnerabilities
   */
  async checkDependencies() {
    const findings = [];
    
    try {
      const packageJsonPath = path.join(__dirname, 'package.json');
      if (fs.existsSync(packageJsonPath)) {
        const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
        
        // Check if package-lock.json exists
        const lockFilePath = path.join(__dirname, 'package-lock.json');
        if (!fs.existsSync(lockFilePath)) {
          findings.push({
            id: 'NO_LOCK_FILE',
            title: 'Missing package-lock.json',
            description: 'The package-lock.json file is missing, which could lead to inconsistent dependencies',
            severity: 'medium',
            location: packageJsonPath,
            recommendation: 'Run \'npm install\' to generate package-lock.json'
          });
        }
        
        // We could integrate with npm audit here if npm is available
        try {
          const { stdout, stderr } = await execAsync('npm audit --json', { cwd: __dirname });
          if (stderr && stderr.includes('not found')) {
            // npm not available, skip this check
          } else {
            const auditResult = JSON.parse(stdout);
            if (auditResult.metadata && auditResult.metadata.vulnerabilities) {
              const vulns = auditResult.metadata.vulnerabilities;
              if (vulns.critical > 0 || vulns.high > 0) {
                findings.push({
                  id: 'DEPENDENCY_VULNS',
                  title: 'Dependency vulnerabilities found',
                  description: `Found ${vulns.critical} critical, ${vulns.high} high, ${vulns.medium} medium, ${vulns.low} low vulnerabilities`,
                  severity: vulns.critical > 0 ? 'critical' : 
                          vulns.high > 0 ? 'high' : 'medium',
                  location: 'Dependencies',
                  recommendation: 'Run \'npm audit\' for details and \'npm audit fix\' to resolve'
                });
              }
            }
          }
        } catch (auditError) {
          // npm audit might fail if not available or if no vulnerabilities found
          // This is okay, we'll just skip this check
        }
      }
    } catch (error) {
      findings.push({
        id: 'DEPENDENCY_CHECK_ERROR',
        title: 'Error checking dependencies',
        description: `Failed to check dependencies: ${error.message}`,
        severity: 'low',
        location: 'Dependencies',
        recommendation: 'Verify package.json file'
      });
    }
    
    return findings;
  }

  /**
   * Check for outdated components
   */
  async checkOutdatedComponents() {
    const findings = [];
    
    // Check if our security components are up to date
    // This would typically involve checking against a version registry
    // For now, we'll just note that this should be done
    
    findings.push({
      id: 'COMPONENT_UPDATE_CHECK',
      title: 'Component update check',
      description: 'Regular check for updates to security components should be performed',
      severity: 'low',
      location: 'System Maintenance',
      recommendation: 'Set up automated update checking for security components'
    });
    
    return findings;
  }

  /**
   * Get system information for scan report
   */
  async getSystemInfo() {
    return {
      platform: process.platform,
      arch: process.arch,
      nodeVersion: process.version,
      uptime: process.uptime(),
      memoryUsage: process.memoryUsage(),
      securityServiceRunning: await this.isSecurityServiceRunning()
    };
  }

  /**
   * Check if security service is running
   */
  async isSecurityServiceRunning() {
    try {
      const healthCheck = await this.httpGet('http://localhost:3009/health');
      return healthCheck.status === 200 && healthCheck.data.status === 'healthy';
    } catch (error) {
      return false;
    }
  }

  /**
   * Save scan report to file
   */
  async saveScanReport(report) {
    const reportsDir = path.join(__dirname, 'security_reports');
    if (!fs.existsSync(reportsDir)) {
      fs.mkdirSync(reportsDir, { recursive: true });
    }
    
    const filename = `vulnerability_scan_${report.timestamp.replace(/[:.]/g, '-')}.json`;
    const filepath = path.join(reportsDir, filename);
    
    fs.writeFileSync(filepath, JSON.stringify(report, null, 2));
  }

  /**
   * Generate and display scan summary
   */
  generateScanSummary(report) {
    console.log(`\nğŸ“Š Vulnerability Scan Summary:`);
    console.log(`   Timestamp: ${report.timestamp}`);
    console.log(`   Duration: ${report.duration}ms`);
    console.log(`   Total Findings: ${report.findings.length}`);
    console.log(`   Critical: ${report.severityStats.critical}`);
    console.log(`   High: ${report.severityStats.high}`);
    console.log(`   Medium: ${report.severityStats.medium}`);
    console.log(`   Low: ${report.severityStats.low}`);
    
    if (report.findings.length > 0) {
      console.log(`\nğŸ” Top Findings:`);
      const topFindings = report.findings
        .sort((a, b) => this.severityToNumber(b.severity) - this.severityToNumber(a.severity))
        .slice(0, 5);
      
      topFindings.forEach((finding, index) => {
        console.log(`   ${index + 1}. [${finding.severity.toUpperCase()}] ${finding.title}`);
        console.log(`      Location: ${finding.location}`);
      });
    } else {
      console.log(`\nâœ… No vulnerabilities detected! System appears secure.`);
    }
  }

  /**
   * Send alert for critical issues
   */
  sendAlert(alertType, data) {
    console.log(`ğŸš¨ ALERT: ${alertType}`, data);
    // In a real system, this would send notifications to administrators
  }

  /**
   * Get all files in directory recursively
   */
  getAllFiles(dirPath, arrayOfFiles = []) {
    const files = fs.readdirSync(dirPath);

    files.forEach(file => {
      if (fs.statSync(dirPath + "/" + file).isDirectory()) {
        arrayOfFiles = this.getAllFiles(dirPath + "/" + file, arrayOfFiles);
      } else {
        arrayOfFiles.push(path.join(dirPath, "/", file));
      }
    });

    return arrayOfFiles;
  }

  /**
   * Get line number for offset in text
   */
  getLineNumberOfOffset(text, offset) {
    const lines = text.substring(0, offset).split('\n');
    return lines.length;
  }

  /**
   * HTTP GET helper
   */
  httpGet(url) {
    return new Promise((resolve, reject) => {
      const http = require('http');
      
      http.get(url, (res) => {
        let data = '';
        
        res.on('data', (chunk) => {
          data += chunk;
        });
        
        res.on('end', () => {
          try {
            resolve({
              status: res.statusCode,
              data: JSON.parse(data)
            });
          } catch (e) {
            resolve({
              status: res.statusCode,
              data: data
            });
          }
        });
      }).on('error', (err) => {
        reject(err);
      });
    });
  }

  /**
   * Convert severity to number for sorting
   */
  severityToNumber(severity) {
    switch(severity) {
      case 'critical': return 4;
      case 'high': return 3;
      case 'medium': return 2;
      case 'low': return 1;
      default: return 0;
    }
  }

  /**
   * Stop the vulnerability scanner
   */
  stop() {
    if (this.scanInterval) {
      clearInterval(this.scanInterval);
      console.log('ğŸ›‘ Vulnerability scanner stopped.');
    }
  }

  /**
   * Get scan history
   */
  getScanHistory() {
    return this.scanHistory;
  }

  /**
   * Get latest scan report
   */
  getLatestScan() {
    return this.lastScan;
  }
}

// If running directly, start the scanner
if (require.main === module) {
  const scanner = new VulnerabilityScanner();
  
  // Start scanning every 60 minutes (can be adjusted)
  scanner.startRegularScanning(60);
  
  // Allow graceful shutdown
  process.on('SIGTERM', () => {
    console.log('ğŸ›‘ Shutting down vulnerability scanner...');
    scanner.stop();
    process.exit(0);
  });
  
  process.on('SIGINT', () => {
    console.log('ğŸ›‘ Shutting down vulnerability scanner...');
    scanner.stop();
    process.exit(0);
  });
  
  console.log('ğŸ›¡ï¸  Vulnerability scanner is now monitoring the system for potential security issues.');
}

module.exports = VulnerabilityScanner;

console.log('Vulnerability Scanner module loaded successfully');