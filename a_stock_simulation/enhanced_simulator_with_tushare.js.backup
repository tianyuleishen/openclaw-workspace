/**
 * å¢å¼ºç‰ˆAè‚¡AIç­–ç•¥æ¨¡æ‹Ÿäº¤æ˜“ç³»ç»Ÿï¼ˆé›†æˆTuShareæ•°æ®ï¼‰
 * 
 * ä½¿ç”¨çœŸå®å¸‚åœºæ•°æ®è¿›è¡Œæ¨¡æ‹Ÿäº¤æ˜“
 */

const AStockSimulator = require('./stock_simulator');
const AdvancedStrategy = require('./advanced_strategy');

class EnhancedAStockSimulator extends AStockSimulator {
  constructor(initialCapital = 100000, token = null) {
    super(initialCapital);
    this.advancedStrategy = new AdvancedStrategy();
    this.positionHistory = {};
    this.profitTargets = {};
    this.tuShareToken = token; // TuShareæ¥å£Token
    this.dailyUpdates = []; // è®°å½•æ¯æ—¥æ›´æ–°
    
    // ç³»ç»Ÿé…ç½®
    this.config = {
      maxPositions: 8,        // æœ€å¤§æŒä»“æ•°é‡
      riskPerTrade: 0.03,     // å•æ¬¡é£é™©3%
      stopLoss: 0.08,         // æ­¢æŸ8%
      takeProfit: 0.15,       // æ­¢ç›ˆ15%
      minVolume: 1000000,     // æœ€å°æˆäº¤é‡
      rebalanceThreshold: 0.1 // å†å¹³è¡¡é˜ˆå€¼
    };
    
    console.log(`ğŸš€ å¢å¼ºç‰ˆAè‚¡AIç­–ç•¥æ¨¡æ‹Ÿäº¤æ˜“ç³»ç»Ÿå·²å¯åŠ¨`);
    console.log(`ğŸ”‘ TuShare Token: ${token ? 'å·²é…ç½®' : 'æœªé…ç½®'}`);
    console.log(`ğŸ“Š ç³»ç»Ÿé…ç½®: æœ€å¤§æŒä»“${this.config.maxPositions}åªï¼Œå•æ¬¡é£é™©${this.config.riskPerTrade*100}%`);
  }

  /**
   * è·å–TuShareæ•°æ®ï¼ˆæ¨¡æ‹Ÿå‡½æ•°ï¼Œå®é™…éœ€è¦å®‰è£…tushareåº“ï¼‰
   */
  async fetchRealMarketData(symbols, startDate, endDate) {
    // è¿™é‡Œæ˜¯æ¨¡æ‹Ÿå®ç°ï¼Œå®é™…éœ€è¦ä½¿ç”¨TuShare API
    console.log(`ğŸ“Š è·å–çœŸå®å¸‚åœºæ•°æ®: ${symbols.join(', ')} (${startDate} to ${endDate})`);
    
    // æ¨¡æ‹Ÿè¿”å›çœŸå®æ ¼å¼çš„æ•°æ®
    const mockData = {};
    for (const symbol of symbols) {
      mockData[symbol] = [];
      // ç”Ÿæˆæ¨¡æ‹Ÿçš„å†å²æ•°æ®
      for (let i = 0; i < 30; i++) {
        const date = new Date();
        date.setDate(date.getDate() - (30 - i));
        
        // ç”Ÿæˆç¬¦åˆå®é™…å¸‚åœºç‰¹å¾çš„ä»·æ ¼æ•°æ®
        const basePrice = symbol === '000001.SZ' ? 15 :
                         symbol === '600000.SH' ? 8 :
                         symbol === '000858.SZ' ? 35 :
                         symbol === '002594.SZ' ? 25 :
                         symbol === '600519.SH' ? 1800 : 10;
        
        const open = basePrice * (0.99 + Math.random() * 0.02);
        const high = open * (1 + Math.random() * 0.03);
        const low = open * (0.97 + Math.random() * 0.02);
        const close = low + Math.random() * (high - low);
        const volume = Math.floor(1000000 + Math.random() * 9000000);
        
        mockData[symbol].push({
          date: date.toISOString().split('T')[0],
          open: parseFloat(open.toFixed(2)),
          high: parseFloat(high.toFixed(2)),
          low: parseFloat(low.toFixed(2)),
          close: parseFloat(close.toFixed(2)),
          volume: volume,
          turnover: close * volume // æˆäº¤é¢
        });
      }
    }
    
    return mockData;
  }

  /**
   * è·å–å®æ—¶æ•°æ®ï¼ˆæ¨¡æ‹Ÿï¼‰
   */
  async fetchRealTimeData(symbols) {
    console.log(`ğŸ“¡ è·å–å®æ—¶æ•°æ®: ${symbols.join(', ')}`);
    
    const realTimeData = {};
    for (const symbol of symbols) {
      // è·å–æœ€æ–°ä»·æ ¼
      const historicalData = this.marketData[symbol] || await this.fetchRealMarketData([symbol], '20260101', '20260203');
      const latest = historicalData[symbol] ? historicalData[symbol][historicalData[symbol].length - 1] : null;
      
      if (latest) {
        // åŸºäºæ˜¨æ—¥æ”¶ç›˜ä»·ç”Ÿæˆä»Šæ—¥ä»·æ ¼æ³¢åŠ¨
        const yesterdayClose = latest.close;
        const fluctuation = (Math.random() - 0.5) * 0.03; // Â±1.5%æ³¢åŠ¨
        const todayPrice = yesterdayClose * (1 + fluctuation);
        
        realTimeData[symbol] = {
          symbol: symbol,
          price: parseFloat(todayPrice.toFixed(2)),
          changePercent: parseFloat((fluctuation * 100).toFixed(2)),
          volume: Math.floor(latest.volume * (0.8 + Math.random() * 0.4)),
          turnover: parseFloat((todayPrice * latest.volume * (0.8 + Math.random() * 0.4)).toFixed(0))
        };
      }
    }
    
    return realTimeData;
  }

  /**
   * ä¼˜åŒ–çš„äº¤æ˜“ä¿¡å·ç”Ÿæˆï¼ˆç»“åˆçœŸå®æ•°æ®ï¼‰
   */
  async generateEnhancedSignal(symbol) {
    try {
      // è·å–å®æ—¶æ•°æ®
      const realTimeData = await this.fetchRealTimeData([symbol]);
      const currentPrice = realTimeData[symbol]?.price || 10; // é»˜è®¤ä»·æ ¼
      
      // è·å–å†å²æ•°æ®ç”¨äºæŠ€æœ¯åˆ†æ
      if (!this.marketData[symbol] || this.marketData[symbol].length < 20) {
        const historical = await this.fetchRealMarketData([symbol], '20260101', '20260203');
        this.marketData[symbol] = historical[symbol] || [];
      }
      
      const stockData = this.marketData[symbol];
      if (stockData.length < 20) {
        return { action: 'HOLD', symbol, quantity: 0, price: currentPrice };
      }
      
      const fundamentals = this.generateMockFundamentals(symbol);
      
      // ä½¿ç”¨é«˜çº§ç­–ç•¥ç”Ÿæˆä¿¡å·
      const signal = this.advancedStrategy.generateSignal(symbol, stockData, fundamentals);
      
      // æ£€æŸ¥æŒä»“æƒ…å†µå’Œæ­¢ç›ˆæ­¢æŸæ¡ä»¶
      const currentPosition = this.portfolio[symbol] ? this.portfolio[symbol].quantity : 0;
      
      // æ£€æŸ¥æ˜¯å¦è§¦å‘æ­¢ç›ˆ/æ­¢æŸ
      if (currentPosition > 0 && this.portfolio[symbol]) {
        const avgBuyPrice = this.portfolio[symbol].avgPrice;
        const currentReturn = (currentPrice - avgBuyPrice) / avgBuyPrice;
        
        // æ­¢ç›ˆæ¡ä»¶ï¼šæ”¶ç›Šè¶…è¿‡15%
        if (currentReturn >= this.config.takeProfit) {
          console.log(`ğŸ¯ è§¦å‘æ­¢ç›ˆ: ${symbol} æ”¶ç›Š ${(currentReturn*100).toFixed(2)}%`);
          return { action: 'SELL', symbol, quantity: currentPosition, price: currentPrice };
        }
        // æ­¢æŸæ¡ä»¶ï¼šäºæŸè¶…è¿‡8%
        else if (currentReturn <= -this.config.stopLoss) {
          console.log(`ğŸš¨ è§¦å‘æ­¢æŸ: ${symbol} äºæŸ ${Math.abs(currentReturn*100).toFixed(2)}%`);
          return { action: 'SELL', symbol, quantity: currentPosition, price: currentPrice };
        }
      }
      
      // å¦‚æœæ²¡æœ‰æŒä»“ï¼Œæ£€æŸ¥ä¹°å…¥æ¡ä»¶
      if (currentPosition === 0) {
        if (signal.action.includes('BUY')) {
          // æ£€æŸ¥æˆäº¤é‡æ˜¯å¦æ»¡è¶³æœ€ä½è¦æ±‚
          const volumeOK = realTimeData[symbol]?.volume >= this.config.minVolume;
          
          if (volumeOK) {
            const totalValue = this.getCurrentPortfolioValue();
            const riskAmount = totalValue * this.config.riskPerTrade;
            const quantity = Math.floor(riskAmount / currentPrice);
            
            // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æœ€å¤§æŒä»“é™åˆ¶
            const positionCount = Object.keys(this.portfolio).length;
            if (positionCount >= this.config.maxPositions) {
              return { action: 'HOLD', symbol, quantity: 0, price: currentPrice };
            }
            
            // æ£€æŸ¥èµ„é‡‘æ˜¯å¦è¶³å¤Ÿ
            const cost = quantity * currentPrice;
            if (cost > this.currentCapital) {
              // æŒ‰æ¯”ä¾‹å‡å°‘è´­ä¹°æ•°é‡
              const affordableQty = Math.floor(this.currentCapital * 0.8 / currentPrice); // ä¿ç•™20%ç°é‡‘
              if (affordableQty > 10) { // è‡³å°‘è´­ä¹°10è‚¡
                return { action: 'BUY', symbol, quantity: affordableQty, price: currentPrice };
              } else {
                return { action: 'HOLD', symbol, quantity: 0, price: currentPrice };
              }
            }
            
            console.log(`ğŸ’¡ ä¹°å…¥ä¿¡å·: ${symbol} åŸºäº${signal.recommendation} (å› å­å¾—åˆ†: ${signal.score?.toFixed(2)})`);
            return { action: 'BUY', symbol, quantity, price: currentPrice };
          }
        }
      }
      
      // å¦‚æœæŒæœ‰ä½†ä¸æ»¡è¶³æ­¢ç›ˆæ­¢æŸæ¡ä»¶ï¼Œç»§ç»­æŒæœ‰
      return { action: 'HOLD', symbol, quantity: currentPosition, price: currentPrice };
    } catch (error) {
      console.error(`âŒ ç”Ÿæˆäº¤æ˜“ä¿¡å·æ—¶å‡ºé”™ (${symbol}):`, error.message);
      return { action: 'HOLD', symbol, quantity: 0, price: 10 }; // é»˜è®¤ä»·æ ¼
    }
  }

  /**
   * æ¯æ—¥æ¨¡æ‹Ÿäº¤æ˜“æ‰§è¡Œ
   */
  async dailySimulation(symbols = ['000001.SZ', '600000.SH', '000858.SZ', '002594.SZ', '600519.SH']) {
    console.log(`\nğŸ“† å¼€å§‹æ¯æ—¥æ¨¡æ‹Ÿäº¤æ˜“ (${new Date().toLocaleDateString('zh-CN')})`);
    
    // è·å–å®æ—¶æ•°æ®
    const realTimeData = await this.fetchRealTimeData(symbols);
    console.log(`ğŸ“Š å®æ—¶å¸‚åœºæ•°æ®è·å–å®Œæˆ`);
    
    // è®°å½•äº¤æ˜“å‰çŠ¶æ€
    const beforeValue = this.getCurrentPortfolioValue();
    console.log(`ğŸ’° äº¤æ˜“å‰æ€»èµ„äº§: Â¥${beforeValue.toFixed(2)}`);
    
    let tradeCount = 0;
    
    // ä¸ºæ¯ä¸ªè‚¡ç¥¨ç”Ÿæˆäº¤æ˜“ä¿¡å·å¹¶æ‰§è¡Œ
    for (const symbol of symbols) {
      try {
        const signal = await this.generateEnhancedSignal(symbol);
        if (signal && signal.action !== 'HOLD') {
          const executed = this.executeTransaction(signal.action, symbol, signal.quantity, signal.price);
          if (executed) {
            console.log(`âœ… æ‰§è¡Œ: ${signal.action} ${signal.symbol} ${signal.quantity}è‚¡ @ Â¥${signal.price.toFixed(2)}`);
            tradeCount++;
          }
        }
      } catch (error) {
        console.error(`âŒ å¤„ç†è‚¡ç¥¨ ${symbol} æ—¶å‡ºé”™:`, error.message);
      }
    }
    
    // è®°å½•äº¤æ˜“åçŠ¶æ€
    const afterValue = this.getCurrentPortfolioValue();
    const dailyPnL = afterValue - beforeValue;
    const dailyReturn = ((afterValue - beforeValue) / beforeValue * 100).toFixed(2);
    
    console.log(`ğŸ’° äº¤æ˜“åæ€»èµ„äº§: Â¥${afterValue.toFixed(2)}`);
    console.log(`ğŸ“ˆ æœ¬æ—¥ç›ˆäº: Â¥${dailyPnL.toFixed(2)} (${dailyReturn}%)`);
    console.log(`ğŸ“Š æœ¬æ—¥äº¤æ˜“: ${tradeCount} æ¬¡`);
    
    // è®°å½•æ¯æ—¥æ›´æ–°
    this.dailyUpdates.push({
      date: new Date().toISOString().split('T')[0],
      startValue: beforeValue,
      endValue: afterValue,
      dailyPnL: dailyPnL,
      dailyReturn: parseFloat(dailyReturn),
      tradeCount: tradeCount,
      holdings: Object.keys(this.portfolio).length
    });
    
    // è¾“å‡ºæŠ•èµ„ç»„åˆæ‘˜è¦
    console.log(`ğŸ“‹ æŒä»“æ‘˜è¦: ${Object.keys(this.portfolio).length} åªè‚¡ç¥¨`);
    for (const sym in this.portfolio) {
      const holding = this.portfolio[sym];
      if (this.marketData[sym] && this.marketData[sym].length > 0) {
        const currentPrice = realTimeData[sym]?.price || this.marketData[sym][this.marketData[sym].length - 1].close;
        const currentValue = holding.quantity * currentPrice;
        const avgPrice = holding.avgPrice;
        const returnPct = ((currentPrice - avgPrice) / avgPrice * 100).toFixed(2);
        console.log(`   â€¢ ${sym}: ${holding.quantity}è‚¡, æˆæœ¬Â¥${avgPrice.toFixed(2)}, å½“å‰Â¥${currentPrice.toFixed(2)}, æ”¶ç›Š${returnPct}%`);
      }
    }
    
    this.tradingDays++;
    
    return {
      date: new Date().toISOString().split('T')[0],
      startValue: beforeValue,
      endValue: afterValue,
      dailyPnL: dailyPnL,
      dailyReturn: parseFloat(dailyReturn),
      tradeCount: tradeCount
    };
  }

  /**
   * æ‰§è¡Œäº¤æ˜“ - å¢å¼ºç‰ˆ
   */
  executeTransaction(action, symbol, quantity, price) {
    if (quantity <= 0) return false;
    
    // è®¡ç®—äº¤æ˜“æˆæœ¬ï¼ˆAè‚¡äº¤æ˜“æˆæœ¬ï¼‰
    let cost = quantity * price;
    let actualQuantity = quantity;
    
    if (action === 'BUY') {
      // Aè‚¡ä¹°å…¥æˆæœ¬ï¼šäº¤æ˜“é‡‘é¢ * 0.0001 (è¿‡æˆ·è´¹) + max(5, äº¤æ˜“é‡‘é¢ * 0.00025) (ä½£é‡‘)
      const commission = Math.max(5, cost * 0.00025);
      const transferFee = cost * 0.0001;
      cost += commission + transferFee;
      
      if (cost > this.currentCapital) {
        // è°ƒæ•´è´­ä¹°æ•°é‡ä»¥é€‚åº”å¯ç”¨èµ„é‡‘
        const availableFunds = this.currentCapital * 0.95; // ä¿ç•™5%ç°é‡‘
        actualQuantity = Math.floor(availableFunds / price);
        if (actualQuantity < 10) { // è‡³å°‘è´­ä¹°10è‚¡
          console.log(`âŒ èµ„é‡‘ä¸è¶³ï¼Œæ— æ³•ä¹°å…¥ ${symbol}`);
          return false;
        }
        cost = actualQuantity * price;
        const adjustedCommission = Math.max(5, cost * 0.00025);
        const adjustedTransferFee = cost * 0.0001;
        cost = cost + adjustedCommission + adjustedTransferFee;
        
        if (cost > this.currentCapital) {
          console.log(`âŒ èµ„é‡‘ä¸è¶³ï¼Œæ— æ³•ä¹°å…¥ ${symbol}`);
          return false;
        }
      }
      
      // æ‰§è¡Œä¹°å…¥
      if (!this.portfolio[symbol]) {
        this.portfolio[symbol] = { quantity: 0, avgPrice: 0 };
      }
      
      const oldTotal = this.portfolio[symbol].quantity * this.portfolio[symbol].avgPrice;
      const newTotal = oldTotal + cost;
      const newQuantity = this.portfolio[symbol].quantity + actualQuantity;
      
      this.portfolio[symbol].avgPrice = newTotal / newQuantity;
      this.portfolio[symbol].quantity = newQuantity;
      this.currentCapital -= cost;
      
      console.log(`âœ… ä¹°å…¥ ${actualQuantity} è‚¡ ${symbol} @ Â¥${price.toFixed(2)}, è€—èµ„ Â¥${cost.toFixed(2)}`);
    } else if (action === 'SELL') {
      if (!this.portfolio[symbol] || this.portfolio[symbol].quantity < quantity) {
        console.log(`âŒ æŒä»“ä¸è¶³ï¼Œæ— æ³•å–å‡º ${symbol}`);
        return false;
      }
      
      // Aè‚¡å–å‡ºæˆæœ¬ï¼šäº¤æ˜“é‡‘é¢ * 0.0001 (è¿‡æˆ·è´¹) + max(5, äº¤æ˜“é‡‘é¢ * 0.00025) (ä½£é‡‘) + äº¤æ˜“é‡‘é¢ * 0.001 (å°èŠ±ç¨)
      const revenue = quantity * price;
      const commission = Math.max(5, revenue * 0.00025);
      const transferFee = revenue * 0.0001;
      const tax = revenue * 0.001; // å°èŠ±ç¨
      const totalCost = commission + transferFee + tax;
      const netRevenue = revenue - totalCost;
      
      // æ‰§è¡Œå–å‡º
      this.portfolio[symbol].quantity -= quantity;
      
      if (this.portfolio[symbol].quantity === 0) {
        delete this.portfolio[symbol];
      }
      
      this.currentCapital += netRevenue;
      
      const profit = netRevenue - (quantity * this.portfolio[symbol]?.avgPrice || price);
      console.log(`âœ… å–å‡º ${quantity} è‚¡ ${symbol} @ Â¥${price.toFixed(2)}, å‡€æ”¶å…¥ Â¥${netRevenue.toFixed(2)}, æ”¶ç›Š Â¥${profit.toFixed(2)}`);
    }
    
    // è®°å½•äº¤æ˜“å†å²
    this.transactionHistory.push({
      date: new Date().toISOString(),
      action,
      symbol,
      quantity: actualQuantity,
      price,
      value: action === 'BUY' ? -cost : (revenue - totalCost),
      capitalAfter: this.currentCapital,
      commission: action === 'BUY' ? (cost - quantity * price) : totalCost
    });
    
    return true;
  }

  /**
   * è·å–ç³»ç»ŸçŠ¶æ€æŠ¥å‘Š
   */
  getStatusReport() {
    const currentValue = this.getCurrentPortfolioValue();
    const totalReturn = ((currentValue - this.initialCapital) / this.initialCapital) * 100;
    
    console.log(`\nğŸ“‹ ç³»ç»ŸçŠ¶æ€æŠ¥å‘Š:`);
    console.log(`ğŸ’° å½“å‰ç°é‡‘: Â¥${this.currentCapital.toFixed(2)}`);
    console.log(`ğŸ“Š æŠ•èµ„ç»„åˆä»·å€¼: Â¥${(currentValue - this.currentCapital).toFixed(2)}`);
    console.log(`ğŸ“ˆ æ€»èµ„äº§: Â¥${currentValue.toFixed(2)}`);
    console.log(`ğŸ“ˆ æ€»æ”¶ç›Š: ${totalReturn.toFixed(2)}% (Â¥${(currentValue - this.initialCapital).toFixed(2)})`);
    console.log(`ğŸ“Š æŒä»“æ•°é‡: ${Object.keys(this.portfolio).length} åª`);
    console.log(`ğŸ“Š äº¤æ˜“å¤©æ•°: ${this.tradingDays}`);
    console.log(`ğŸ“Š æ€»äº¤æ˜“æ¬¡æ•°: ${this.transactionHistory.filter(tx => tx.action !== 'HOLD').length}`);
    
    if (this.dailyUpdates.length > 0) {
      const recentUpdates = this.dailyUpdates.slice(-7); // æœ€è¿‘7å¤©
      console.log(`ğŸ“Š æœ€è¿‘7æ—¥è¡¨ç°:`);
      recentUpdates.forEach(update => {
        console.log(`   ${update.date}: ${update.dailyReturn}% (${update.tradeCount}ç¬”äº¤æ˜“)`);
      });
    }
    
    return {
      currentCash: this.currentCapital,
      portfolioValue: currentValue - this.currentCapital,
      totalValue: currentValue,
      totalReturn: totalReturn,
      holdingsCount: Object.keys(this.portfolio).length,
      tradingDays: this.tradingDays,
      totalTransactions: this.transactionHistory.filter(tx => tx.action !== 'HOLD').length,
      recentPerformance: this.dailyUpdates.slice(-7)
    };
  }
}

// å¦‚æœç›´æ¥è¿è¡Œæ­¤è„šæœ¬ï¼Œæ‰§è¡Œç¤ºä¾‹
if (require.main === module) {
  console.log("ğŸ¯ å¢å¼ºç‰ˆAè‚¡AIç­–ç•¥æ¨¡æ‹Ÿäº¤æ˜“ç³»ç»Ÿï¼ˆé›†æˆTuShareæ•°æ®ï¼‰");
  console.log("=" .repeat(70));
  
  // ä½¿ç”¨æä¾›çš„Token
  const TU_SHARE_TOKEN = '06dcd1581204b5fbf16a2d500fbba9b7fab80d38329b1e7cc2069f03';
  
  const simulator = new EnhancedAStockSimulator(100000, TU_SHARE_TOKEN);
  
  // æ¼”ç¤ºå•æ—¥æ¨¡æ‹Ÿäº¤æ˜“
  console.log("\nğŸ” æ¼”ç¤ºå•æ—¥æ¨¡æ‹Ÿäº¤æ˜“æµç¨‹:");
  simulator.dailySimulation(['000001.SZ', '600000.SH', '000858.SZ'])
    .then(result => {
      console.log("\nğŸ“ˆ å•æ—¥äº¤æ˜“å®Œæˆï¼Œç”ŸæˆçŠ¶æ€æŠ¥å‘Š:");
      simulator.getStatusReport();
      
      console.log("\n" + "=".repeat(70));
      console.log("ğŸ’¡ ç³»ç»Ÿç‰¹æ€§:");
      console.log("â€¢ é›†æˆçœŸå®å¸‚åœºæ•°æ®ï¼ˆæ¨¡æ‹ŸTuShareæ¥å£ï¼‰");
      console.log("â€¢ åŠ¨æ€æ­¢ç›ˆæ­¢æŸæœºåˆ¶ï¼ˆ8%æ­¢æŸï¼Œ15%æ­¢ç›ˆï¼‰");
      console.log("â€¢ é£é™©ç®¡ç†ï¼ˆ3%å•æ¬¡é£é™©ï¼Œ8åªæœ€å¤§æŒä»“ï¼‰");
      console.log("â€¢ å®æ—¶æŒä»“è·Ÿè¸ªä¸ç›ˆäºè®¡ç®—");
      console.log("â€¢ æ¯æ—¥äº¤æ˜“æ—¥å¿—ä¸æ€§èƒ½åˆ†æ");
      
      console.log("\nâš ï¸  æ³¨æ„äº‹é¡¹:");
      console.log("â€¢ å®é™…éƒ¨ç½²éœ€è¦å®‰è£…tushareåº“å¹¶é…ç½®çœŸå®API");
      console.log("â€¢ éœ€è¦éµå®ˆTuShareçš„è°ƒç”¨é¢‘ç‡é™åˆ¶");
      console.log("â€¢ æ¨¡æ‹Ÿç»“æœä»…ä¾›å‚è€ƒï¼Œä¸æ„æˆæŠ•èµ„å»ºè®®");
    })
    .catch(error => {
      console.error("âŒ æ¨¡æ‹Ÿäº¤æ˜“æ‰§è¡Œå‡ºé”™:", error);
    });
}

module.exports = EnhancedAStockSimulator;